//F（N，K）= Min（Max（ F（N-X，K）+ 1， F（X-1，K-1） + 1）），1<=X<=N
//状态方程 : dp[N,k] = dp[N-1][K] + dp[N][M-1] + 1
/*
    假设移动x次,k个鸡蛋,最优解的最坏条件下可以检测n层楼,层数n=黑箱子函数f(x,k)

    假设从n0+1层丢下鸡蛋,
    1,鸡蛋破了gg
        剩下x-1次机会和k-1个鸡蛋,可以检测n0层楼
    2, 鸡蛋没破
        剩下x-1次机会和k个鸡蛋,可以检测n1层楼
    
    那么 临界值层数F在[1,n0+n1+1]中的任何一个值,都都能被检测出来

归纳的状态转移方程式为:f(x,k) = f(x-1,k-1)+f(x-1,k)+1,即x次移动的函数值可以由x-1的结果推导,这个思路很抽象,需要花时间去理解,具体看代码,对照着代码理解

可以简化为黑箱子函数的返回值只跟鸡蛋个数k有关系:
本次fun(k) = 上次fun(k-1)+上次fun(k)+1
*/
class Solution {
public:
    int superEggDrop(int K, int N) {
        
        vector<int> dp(K + 1, 0);
        int m = 0;
        while (dp[K] < N) {//表示当能够测试的最大楼层数刚好是我们需要的楼层数N时，此时取得m的最小值。
            m++;
            for (int k = K; k > 0; --k) {
                dp[k] = dp[k-1] + dp[k] + 1;//逆向遍历，不断更新dp[k],使得dp[k]取最大值(能够测试的最大楼层数)
            }
        }
        return m;
    
        
    }
};
