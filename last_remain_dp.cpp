class Solution{
public:

	//f(n,m): n个数,每次删除第m个最后剩下的一个数的下标
	//如: n=8,m=3
	//下面的左移右移都是在0-7下标内循环
	//正向删除一次
	//下标 0  1   2   3   4   5   6    7      
	//     0  1   2   3   4   5   6    7   
	//删除2,以2后位置为新的起点,左移三个
	//     3  4   5   6   7   0   1        
	//以此规律删除  得 f(8,3) = 6 
	//        也就得出 f(7,3) = 3  f(6,3)=...

	//7~8 反向恢复
	//下标   0  1   2   3   4   5   6    7      
	//原数组 0  1   2   3   4   5   6    7
	//删除后 3  4   5   6   7   0   1
	//以2前位置为原位置补3,右移三个,3刚好回到原位置
	//f(8,3) = (f(7,3)+3)%8   
	//f(n,m) = (f(n-1,m)+m)%n
	
	//动态规划
	//自下而上
	//f: 剩下数的下标
	//最初状态: f(1,m) = 0;
	//递推: f = (f+m)%n 
	int LastRemain(int n, int m)
	{
		//无效输入
		if (n < 1 || m < 1) return 0;
			
		int flag = 0;
		for (int i = 2; i <= n; i++) {
			flag = (flag + m) % i;
			//动态规划的思想，将f(n,m)替换成flag存储
		}
		return flag;
	}
};
